#include <iostream>
#include <fstream>
#include <vector>
#include <random>

std::string init_mode;                      // Initial conditions of the sandpile model (random or unstable)

static int width;                           // Width of the arena for the sandpile
static int height;                          // Height of the arena for the sandpile

static int scale_factor;                    // Maximum possible value for a slope
static int critical_slope;                  // Critical degree of slope before avalanche occurs

std::vector<std::vector<int>> sandpile;     // Storage for current state of the sandpile
std::vector<std::vector<int>> new_sandpile; // Temporary storage for upgrading the sandpile

double roll_random_number(int N) {
    // Roll a random float from between the given interval
    std::random_device randomized;                           // Will be used to obtain a seed for the random number engine
    std::mt19937 generate(randomized());                     // Standard mersenne_twister_engine seeded with randomized()
    
    // Use dis to transform the random unsigned int generated by gen into a 
    // double in [0, N). Each call to distribution(generate) generates a new random double.
    std::uniform_real_distribution<> distribution(0, N);

    double random_number = distribution(generate);

    return random_number;
}

// Initializing the starting position of the sandpile
// Either random, or unstable with scale_factor grains in every point
void init_starting_pos() {

    for(int i = 0; i < height; i++) {
        std::vector<int> temp_vec;
        for(int j = 0; j < width; j++) {
            if(i == 0 || j == 0 || i == height-1 || j == width-1) {
                temp_vec.push_back(0);
            }
            else {
                if(init_mode == "random") {
                    temp_vec.push_back(static_cast<int>(roll_random_number(scale_factor+1)));
                }
                else if(init_mode == "unstable") {
                    temp_vec.push_back(scale_factor);
                }
            }
        }
        sandpile.push_back(temp_vec);
    }

    new_sandpile = sandpile;
}

// Abelian sandpile model
// If F(x,y) > 3
// Then: 
//      F(x,y) -> F(x,y) - 4
//      F(x+-1,y) -> F(x+-1,y) + 1
//      F(x,y+-1) -> F(x,y+-1) + 1
void step_with_simulation() {

    for(int i = 1; i < height-1; i++) {
        for(int j = 1; j < width-1; j++) {
            if(sandpile[i][j] > critical_slope) {
                new_sandpile[i][j] -= critical_slope + 1;
                
                // Add them to its neighbours
                new_sandpile[i+1][j] += 1;
                new_sandpile[i-1][j] += 1;
                new_sandpile[i][j+1] += 1;
                new_sandpile[i][j-1] += 1;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    std::cout << "Sandpile automaton\n"
              << " -----------------\n";

    init_mode = argv[1];                    // Initial conditions of the sandpile model (random or unstable)

    width = atoi(argv[2]) + 2;              // Width of the arena for the sandpile   | +1s span a 1x1 border
    height = atoi(argv[3]) + 2;             // Height of the arena for the sandpile  | around the actual arena

    int sim_steps = atoi(argv[4]);          // Total number of simulated steps

    scale_factor = atoi(argv[5]);           // Maximum possible value for a slope
    //critical_slope = atoi(argv[6]);         // Critical degree of slope before avalanche occurs
    critical_slope = 3;

    // Initializing the starting position of the sandpile
    init_starting_pos();

    // Run the simulation and log outputs
    std::ofstream dataFile;                     // Datafile for outputs
    dataFile.open("..\\out\\sandpile.dat");

    // Write initial state to log
    for(unsigned int i = 1; i < height-1; i++) {
            for(unsigned int j = 1; j < width-1; j++) {
                dataFile << sandpile[i][j] << ' ';
            }
            dataFile << '\n';
        }
        dataFile << '\n';

    for(unsigned int steps = 0; steps < sim_steps; steps++) {

        step_with_simulation();

        // Refresh the arena's memory to
        sandpile = new_sandpile;

        for(unsigned int i = 1; i < height-1; i++) {
            for(unsigned int j = 1; j < width-1; j++) {
                dataFile << sandpile[i][j] << ' ';
            }
            dataFile << '\n';
        }
        dataFile << '\n';
    }
}